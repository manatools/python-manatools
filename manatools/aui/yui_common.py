"""
Common base classes and definitions shared across all backends
"""

from enum import Enum
import uuid
from typing import Optional

# Enums
class YUIDimension(Enum):
    YD_HORIZ = 0
    YD_VERT = 1

class YAlignmentType(Enum):
    YAlignUnchanged = 0
    YAlignBegin = 1
    YAlignEnd = 2
    YAlignCenter = 3

class YDialogType(Enum):
    YMainDialog = 0
    YPopupDialog = 1
    YWizardDialog = 2

class YDialogColorMode(Enum):
    YDialogNormalColor = 0
    YDialogInfoColor = 1
    YDialogWarnColor = 2

class YEventType(Enum):
    NoEvent = 0
    WidgetEvent = 1
    MenuEvent = 2
    KeyEvent = 3
    CancelEvent = 4
    TimeoutEvent = 5

class YEventReason(Enum):
    Activated = 0
    ValueChanged = 1
    SelectionChanged = 2

class YCheckBoxState(Enum):
    YCheckBox_dont_care = -1
    YCheckBox_off = 0
    YCheckBox_on = 1

class YButtonRole(Enum):
    YCustomButton = 0
    YOKButton = 1
    YCancelButton = 2
    YHelpButton = 3

# Exceptions
class YUIException(Exception):
    pass

class YUIWidgetNotFoundException(YUIException):
    pass

class YUINoDialogException(YUIException):
    pass

class YUIInvalidWidgetException(YUIException):
    pass

# Events
class YEvent:
    def __init__(self, event_type=YEventType.NoEvent, widget=None, reason=None):
        self._event_type = event_type
        self._widget = widget
        self._reason = reason
        self._serial = 0
    
    def eventType(self):
        return self._event_type
    
    def widget(self):
        return self._widget
    
    def reason(self):
        return self._reason
    
    def serial(self):
        return self._serial

class YWidgetEvent(YEvent):
    """Event generated by widgets"""
    def __init__(self, widget=None, reason=YEventReason.Activated, event_type=YEventType.WidgetEvent):
        super().__init__(event_type, widget, reason)

class YKeyEvent(YEvent):
    def __init__(self, key_symbol, focus_widget=None):
        super().__init__(YEventType.KeyEvent, focus_widget)
        self._key_symbol = key_symbol
    
    def keySymbol(self):
        return self._key_symbol
    
    def focusWidget(self):
        return self.widget()

class YMenuEvent(YEvent):
    def __init__(self, item=None, id=None):
        super().__init__(YEventType.MenuEvent)
        self._item = item
        self._id = id
    
    def item(self):
        return self._item
    
    def id(self):
        return self._id

class YTimeoutEvent(YEvent):
    """Event generated on timeout"""
    def __init__(self):
        super().__init__(YEventType.TimeoutEvent)

class YCancelEvent(YEvent):
    def __init__(self):
        super().__init__(YEventType.CancelEvent)

# Base Widget Class
class YWidget:
    _widget_counter = 0
    
    def __init__(self, parent=None):
        YWidget._widget_counter += 1
        self._id = f"widget_{YWidget._widget_counter}"
        self._parent = parent
        self._children = []
        self._enabled = True
        self._help_text = ""
        self._backend_widget = None
        self._stretchable_horiz = False
        self._stretchable_vert = False
        self._weight_horiz = 0
        self._weight_vert = 0
        # NOTE: Notify property should be False for back compatibility, 
        # but backends has been implemented as True
        self._notify = True
        self._auto_shortcut = False
        self._function_key = 0
        
        if parent and hasattr(parent, 'addChild'):
            parent.addChild(self)
    
    def widgetClass(self):
        return self.__class__.__name__
    
    def widgetPathName(self):
        ''' Return the full path name of this widget in the hierarchy. '''
        return f"{self._parent.widgetPathName()}/{self.widgetClass()}({self._id})" if self._parent else f"/{self.widgetClass()}({self._id})"
    
    def id(self):
        ''' Return the unique identifier of this widget. '''
        return self._id

    def debugLabel(self):
        return f"{self.widgetClass()}({self._id})"
    
    def helpText(self):
        return self._help_text
    
    def setHelpText(self, help_text):
        self._help_text = help_text
    
    def hasChildren(self):
        return len(self._children) > 0
    
    def firstChild(self):
        return self._children[0] if self._children else None
    
    def lastChild(self):
        return self._children[-1] if self._children else None
    
    def childrenBegin(self):
        return iter(self._children)
    
    def childrenEnd(self):
        return iter([])
    
    def childrenCount(self):
        return len(self._children)
    
    def addChild(self, child):
        if child not in self._children:
            self._children.append(child)
            child._parent = self
            if self.isEnabled() is False:
                child._enabled = False
    
    def removeChild(self, child):
        if child in self._children:
            self._children.remove(child)
            child._parent = None

    def deleteChildren(self):
        """
        Remove all logical children from this widget.

        This clears the internal children list and detaches each child's
        parent reference. Backend containers that render children should
        override this method to also clear any backend layout or content
        area. For generic widgets, this only affects the logical model.
        """
        try:
            for ch in list(self._children):
                try:
                    ch._parent = None
                except Exception:
                    pass
            self._children.clear()
        except Exception:
            # Best-effort: ignore failures and keep model consistent
            try:
                self._children = []
            except Exception:
                pass
    
    def parent(self):
        return self._parent
    
    def hasParent(self):
        return self._parent is not None
    
    def findDialog(self):
        """Find the parent dialog of this widget."""
        parent = getattr(self, '_parent', None)
        while parent is not None and parent.widgetClass() != 'YDialog':
            parent = getattr(parent, '_parent', None)
        return parent

    def setEnabled(self, enabled=True):
        '''
           Enable or disable the widget. i.e. make it accept or reject user input.
           Derived backend classes must implement _set_backend_enabled to apply 
           the change to the actual backend widget.
        '''
        self._enabled = enabled
        self._set_backend_enabled(enabled)
    
    def setDisabled(self):
        self.setEnabled(False)
    
    def isEnabled(self):
        return self._enabled
    
    def stretchable(self, dim):
        if dim == YUIDimension.YD_HORIZ:
            return self._stretchable_horiz
        else:
            return self._stretchable_vert
    
    def setStretchable(self, dim, new_stretch):
        if dim == YUIDimension.YD_HORIZ:
            self._stretchable_horiz = new_stretch
        else:
            self._stretchable_vert = new_stretch
    
    def weight(self, dim):
        """ 
            The weight is used when all widgets can get their preferred size and yet space is available. 
            The remaining space will be devided between all stretchable widgets according to their weights.
            A widget with greater weight will get more space. The default weight for all widgets is 0. 
            The weight range is 0-99.
        """
        if dim == YUIDimension.YD_HORIZ:
            return self._weight_horiz
        else:
            return self._weight_vert
    
    def setWeight(self, dim, weight: int):
        w = weight % 100 if weight >= 0 else 0
        
        if dim == YUIDimension.YD_HORIZ:
            self._weight_horiz = w
        else:
            self._weight_vert = w
    
    def setNotify(self, notify=True):
        self._notify = notify
    
    def notify(self):
        return self._notify
    
    def autoShortcut(self):
        return self._auto_shortcut
    
    def setAutoShortcut(self, auto_shortcut):
        self._auto_shortcut = auto_shortcut
    
    def functionKey(self):
        return self._function_key
    
    def setFunctionKey(self, fkey_no):
        self._function_key = fkey_no
    
    # Backend-specific methods to be implemented by concrete classes
    def _set_backend_enabled(self, enabled):
        pass
    
    def _create_backend_widget(self):
        pass
    
    def get_backend_widget(self):
        if self._backend_widget is None:
            self._create_backend_widget()
        return self._backend_widget

class YSingleChildContainerWidget(YWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
    
    def child(self):
        '''
        Returns the only child of this single-child container, or None if no child is set.       
        '''
        return self.firstChild()

    def addChild(self, child):
        if self.hasChildren():
            raise YUIInvalidWidgetException("YSingleChildContainerWidget can only have one child")
        super().addChild(child)

class YSelectionWidget(YWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._items = []
        self._selected_items = []
        self._label = ""
        self._icon_base_path = ""
    
    def label(self):
        return self._label
    
    def setLabel(self, new_label):
        self._label = new_label
    
    def addItem(self, item):
        if isinstance(item, str):
            item = YItem(item)
        self._items.append(item)

    def addItems(self, items):
        """Add multiple items to the selection widget."""
        for it in items:
            self.addItem(it)
    
    def deleteAllItems(self):
        self._items.clear()
        self._selected_items.clear()
    
    def itemsBegin(self):
        return iter(self._items)
    
    def itemsEnd(self):
        return iter([])
    
    def hasItems(self):
        return len(self._items) > 0
    
    def itemsCount(self):
        return len(self._items)
    
    def selectedItem(self):
        return self._selected_items[0] if self._selected_items else None
    
    def selectedItems(self):
        return self._selected_items
    
    def hasSelectedItem(self):
        return len(self._selected_items) > 0
    
    def selectItem(self, item, selected=True):
        if selected and item not in self._selected_items:
            self._selected_items.append(item)
        elif not selected and item in self._selected_items:
            self._selected_items.remove(item)

class YSimpleInputField(YWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._value = ""
        self._label = ""
    
    def value(self):
        return self._value
    
    def setValue(self, text):
        self._value = text
    
    def label(self):
        return self._label
    
    def setLabel(self, label):
        self._label = label

class YItem:
    def __init__(self, label, selected=False, icon_name=""):
        self._label = label
        self._selected = selected
        self._icon_name = icon_name
        self._index = 0
        self._data = None
    
    def label(self):
        return self._label
    
    def setLabel(self, new_label):
        self._label = new_label
    
    def selected(self):
        return self._selected
    
    def setSelected(self, selected=True):
        self._selected = selected
    
    def iconName(self):
        return self._icon_name
    
    def hasIconName(self):
        return bool(self._icon_name)
    
    def setIconName(self, new_icon_name):
        self._icon_name = new_icon_name
    
    def index(self):
        return self._index
    
    def setIndex(self, index):
        self._index = index
    
    def data(self):
        return self._data
    
    def setData(self, new_data):
        self._data = new_data

class YMenuItem:
    """Lightweight menu item model for backend-agnostic use.

    Supports label, icon name, enabled state and hierarchical children
    (submenus and items). Backends may attach platform-specific references
    via `_backend_ref` for synchronization.
    """
    def __init__(self, label: str, icon_name: str = "", enabled: bool = True, is_menu: bool = False, is_separator: bool = False):
        self._is_separator = bool(is_separator)
        self._label = "-" if self._is_separator else str(label)
        self._icon_name = str(icon_name) if icon_name else ""
        self._enabled = False if self._is_separator else bool(enabled)
        self._is_menu = False if self._is_separator else bool(is_menu)
        # visible flag (backends should respect this when rendering)
        self._visible = True
        self._children = []  # list of YMenuItem
        self._parent = None
        self._backend_ref = None  # optional backend-specific handle

    def label(self) -> str:
        return self._label

    def setLabel(self, new_label: str):
        self._label = str(new_label)

    def iconName(self) -> str:
        return self._icon_name

    def setIconName(self, new_icon_name: str):
        self._icon_name = str(new_icon_name) if new_icon_name else ""

    def enabled(self) -> bool:
        return bool(self._enabled)

    def setEnabled(self, on: bool = True):
        self._enabled = bool(on)

    def visible(self) -> bool:
        return bool(self._visible)

    def setVisible(self, on: bool = True):
        self._visible = bool(on)
        for child in self._children:
            child.setVisible(on)

    def isMenu(self) -> bool:
        return bool(self._is_menu)

    def isSeparator(self) -> bool:
        return bool(self._is_separator)
    
    def parentItem(self):
        return self._parent
    
    def hasChildren(self):
        return len(self._children) > 0

    def childrenBegin(self):
        return iter(self._children)

    def childrenEnd(self):
        return iter([])

    def hasChildren(self) -> bool:
        return len(self._children) > 0

    def addItem(self, label: str, icon_name: str = ""):
        child = YMenuItem(label, icon_name, enabled=True, is_menu=False)
        child._parent = self
        child.setVisible(self.visible())
        self._children.append(child)
        return child

    def addMenu(self, label: str, icon_name: str = ""):
        child = YMenuItem(label, icon_name, enabled=True, is_menu=True)
        child._parent = self
        child.setVisible(self.visible())
        self._children.append(child)
        return child

    def addSeparator(self):
        # Represent separator as a disabled item with label "-"; backends can special-case it.
        sep = YMenuItem("-", is_menu=False, enabled=False, is_separator=True)
        sep._parent = self
        self._children.append(sep)
        return sep

class YTreeItem(YItem):
    def __init__(self, label: str, parent: Optional["YTreeItem"] = None, selected: Optional[bool] = False, is_open: bool = False, icon_name: str = ""):
        ''' YTreeItem represents an item in a tree structure.
            It can have child items and can be expanded or collapsed.'''
        super().__init__(label, selected, icon_name)
        self._children = []
        self._is_open = is_open
        self._parent_item = parent
        if parent:
            parent.addChild(self)
    
    def parentItem(self):
        return self._parent_item
    
    def hasChildren(self):
        return len(self._children) > 0
    
    def childrenBegin(self):
        return iter(self._children)
    
    def childrenEnd(self):
        return iter([])
    
    def addChild(self, item):
        self._children.append(item)
        item._parent_item = self
    
    def isOpen(self):
        return self._is_open
    

class YTableHeader:
    """Helper class for table column properties.

    Tracks columns' header text, alignment and whether a column is a
    checkbox column.
    """
    def __init__(self):
        self._columns = []  # list of dicts: {'header': str, 'alignment': YAlignmentType, 'checkbox': bool}

    def addColumn(self, header, checkBox : Optional[bool] = False, alignment=YAlignmentType.YAlignBegin):
        """Add a column with header text and optional alignment (no checkbox)."""
        self._columns.append({'header': str(header), 'alignment': alignment, 'checkbox': bool(checkBox)})

    def columns(self):
        return len(self._columns)

    def hasColumn(self, column):
        return 0 <= int(column) < len(self._columns)

    def header(self, column):
        try:
            return self._columns[int(column)]['header']
        except Exception:
            return ""

    def isCheckboxColumn(self, column):
        try:
            return bool(self._columns[int(column)]['checkbox'])
        except Exception:
            return False

    def alignment(self, column):
        try:
            return self._columns[int(column)]['alignment']
        except Exception:
            return YAlignmentType.YAlignUnchanged


class YTableCell:
    """One cell (one column in one row) of a YTableItem.

    Supports label, optional icon name, optional sort key and an optional
    checkbox state. Cells can be created detached or with a parent/table
    assigned via `reparent()`.
    """
    def __init__(self, label: str = "", icon_name: str = "", sort_key: str = "", parent: Optional["YTableItem"] = None, column: int = -1, checked: Optional[bool] = None):
        self._label = label
        self._icon_name = icon_name
        self._sort_key = sort_key
        self._parent = parent
        self._column = column
        # checked: None means not-a-checkbox column; True/False represent checkbox state
        self._checked = checked

    def label(self):
        return self._label

    def setLabel(self, new_label: str):
        self._label = new_label

    def iconName(self):
        return self._icon_name

    def setIconName(self, new_icon_name: str):
        self._icon_name = new_icon_name

    def hasIconName(self):
        return bool(self._icon_name)

    def sortKey(self):
        return self._sort_key

    def hasSortKey(self):
        return bool(self._sort_key)

    def parent(self):
        return self._parent

    def column(self):
        return self._column

    def itemIndex(self):
        return self._parent.index() if self._parent is not None else -1

    def reparent(self, parent: "YTableItem", column: int):
        if self._parent is not None:
            raise Exception("Cell already has a parent")
        self._parent = parent
        self._column = column

    # checkbox API
    def setChecked(self, val: bool = True):
        self._checked = bool(val)

    def checked(self):
        return bool(self._checked) if self._checked is not None else False


class YTableItem(YTreeItem):
    """Table item (one row). Each item may contain multiple `YTableCell`.

    Provides convenience constructors and cell management similar to
    the C++ `YTableItem` while also supporting checkbox cells.
    """
    def __init__(self, label: str = "", parent: Optional["YTreeItem"] = None, is_open: bool = False, icon_name: str = ""):
        super().__init__(label, parent, False, is_open, icon_name)
        self._cells = []  # list of YTableCell

    def addCell(self, cell_or_label, icon_name: str = "", sort_key: str = ""):
        """Add a cell instance or create one from label/icon/sort_key.
        If a boolean is passed as first arg, treat it as a checkbox cell value.
        """
        if isinstance(cell_or_label, YTableCell):
            cell = cell_or_label
        else:
            # allow boolean-only constructor for checkbox column
            if isinstance(cell_or_label, bool):
                cell = YTableCell("", "", "", parent=self, column=len(self._cells), checked=cell_or_label)
            else:
                cell = YTableCell(str(cell_or_label), icon_name, sort_key, parent=self, column=len(self._cells))
        # set parent/column and append
        try:
            cell.reparent(self, len(self._cells))
        except Exception:
            # already parented; update column if needed
            cell._column = len(self._cells)
            cell._parent = self
        self._cells.append(cell)

    def addCells(self, *labels):
        for lbl in labels:
            self.addCell(lbl)

    def deleteCells(self):
        self._cells = []

    def cellsBegin(self):
        return iter(self._cells)

    def cellsEnd(self):
        return iter([])

    def cell(self, index: int):
        if not self.hasCell(index):
            return None
        try:
            return self._cells[index]
        except Exception:
            return None

    def cellCount(self):
        return len(self._cells)

    def hasCell(self, index: int):
        return 0 <= index < len(self._cells)

    def label(self, index: int = 0):
        if not self.hasCell(index):
            return ""
        c = self.cell(index)
        return c.label() if c is not None else ""
    
    def checked(self, index: int = 0):
        if not self.hasCell(index):
            return False
        c = self.cell(index)
        return c.checked() if c is not None else False

    def iconName(self, index: int = 0):
        c = self.cell(index)
        return c.iconName() if c is not None else ""

    def hasIconName(self, index: int = 0):
        c = self.cell(index)
        return c.hasIconName() if c is not None else False

    def debugLabel(self):
        return f"{super().debugLabel()}[cells={self.cellCount()}]"

# Property system
class YPropertyType(Enum):
    YUnknownPropertyType = 0
    YOtherProperty = 1
    YStringProperty = 2
    YBoolProperty = 3
    YIntegerProperty = 4

class YProperty:
    def __init__(self, name, prop_type, is_readonly=False):
        self._name = name
        self._type = prop_type
        self._is_readonly = is_readonly
    
    def name(self):
        return self._name
    
    def type(self):
        return self._type
    
    def isReadOnly(self):
        return self._is_readonly

class YPropertyValue:
    def __init__(self, value=None, prop_type=YPropertyType.YUnknownPropertyType):
        self._value = value
        self._type = prop_type
    
    def type(self):
        return self._type
    
    def stringVal(self):
        return str(self._value) if self._value else ""
    
    def boolVal(self):
        return bool(self._value)
    
    def integerVal(self):
        return int(self._value) if self._value else 0

class YPropertySet:
    def __init__(self):
        self._properties = {}
    
    def add(self, prop):
        self._properties[prop.name()] = prop
    
    def contains(self, name):
        return name in self._properties
    
    def isEmpty(self):
        return len(self._properties) == 0

class YShortcut:
    def __init__(self, widget):
        self._widget = widget
        self._shortcut = ''
        self._conflict = False
    
    def widget(self):
        return self._widget
    
    def shortcutString(self):
        return self._shortcut
    
    def setShortcut(self, new_shortcut):
        self._shortcut = new_shortcut
    
    def conflict(self):
        return self._conflict
    
    def setConflict(self, conflict=True):
        self._conflict = conflict